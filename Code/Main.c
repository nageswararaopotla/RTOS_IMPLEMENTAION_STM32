/* main.c - FreeRTOS example for STM32 Nucleo
 *
 * - LED Task: blink an LED every 500 ms
 * - Fan Task: read ADC (temperature sensor) and toggle fan GPIO if threshold exceeded
 * - Motor Task: run PWM ramp up/down on TIM3 channel (motor speed)
 * - Uses a mutex to protect UART prints (xUARTMutex)
 *
 * Before building:
 * - Generate/init MX_GPIO_Init, MX_ADC1_Init, MX_TIM3_Init, MX_USART2_UART_Init via CubeMX or STM32CubeIDE
 * - Ensure TIM3 CH1 is configured for PWM output
 * - Connect temperature sensor to ADC1 channel used in MX_ADC1_Init()
 * - Map LED and FAN pins in CubeMX and change defines below if needed
 */

#include "main.h"
#include "cmsis_os.h"       // CMSIS-RTOS header (if using CubeMX FreeRTOS middleware)
#include "string.h"
#include <stdio.h>

/* Peripheral handles (generated by CubeMX) */
extern ADC_HandleTypeDef hadc1;
extern TIM_HandleTypeDef htim3;
extern UART_HandleTypeDef huart2;

/* --- User-configurable pin definitions --- */
/* Replace these with actual HAL GPIO port/pin names from MX_GPIO_Init() */
#define LED_GPIO_Port      GPIOC
#define LED_Pin            GPIO_PIN_13   // On many Nucleo boards: user LED
#define FAN_GPIO_Port      GPIOB
#define FAN_Pin            GPIO_PIN_0    // Example: change per your wiring

/* ADC threshold (raw ADC value) to turn fan ON */
#define FAN_TEMP_THRESHOLD 2000u  // adjust for your ADC reference and sensor

/* Motor PWM parameters */
#define MOTOR_PWM_MAX      1000  // timer compare value corresponding to 100% duty (adjust per timer config)
#define MOTOR_STEP_DELAY   200   // ms between PWM steps
#define MOTOR_STEP         100   // increment per step (adjust to taste)

/* RTOS objects */
osThreadId_t ledTaskHandle;
osThreadId_t fanTaskHandle;
osThreadId_t motorTaskHandle;
SemaphoreHandle_t xUARTMutex;

/* Forward declarations */
void SystemClock_Config(void);
void MX_GPIO_Init(void);
void MX_ADC1_Init(void);
void MX_TIM3_Init(void);
void MX_USART2_UART_Init(void);

/* Task functions */
void StartLEDTask(void *argument);
void StartFanTask(void *argument);
void StartMotorTask(void *argument);

/* Simple UART printf (uses HAL_UART_Transmit) */
static void uart_printf(const char *fmt, ...)
{
    if (xUARTMutex == NULL) return; // mutex not created
    if (xSemaphoreTake(xUARTMutex, pdMS_TO_TICKS(200)) == pdTRUE)
    {
        char buf[128];
        va_list args;
        va_start(args, fmt);
        int len = vsnprintf(buf, sizeof(buf), fmt, args);
        va_end(args);
        if (len > 0)
        {
            HAL_UART_Transmit(&huart2, (uint8_t*)buf, (uint16_t)len, HAL_MAX_DELAY);
        }
        xSemaphoreGive(xUARTMutex);
    }
}

/* Main */
int main(void)
{
    /* HAL init and system clock */
    HAL_Init();
    SystemClock_Config();

    /* Peripheral init (CubeMX generated functions) */
    MX_GPIO_Init();
    MX_ADC1_Init();
    MX_TIM3_Init();
    MX_USART2_UART_Init();

    /* Start PWM timer (motor) */
    HAL_TIM_PWM_Start(&htim3, TIM_CHANNEL_1);

    /* Create mutex for UART prints */
    xUARTMutex = xSemaphoreCreateMutex();

    /* Create RTOS tasks */
    const osThreadAttr_t ledTask_attributes = {
      .name = "LEDTask",
      .priority = (osPriority_t) osPriorityLow,
      .stack_size = 128 * 4
    };
    ledTaskHandle = osThreadNew(StartLEDTask, NULL, &ledTask_attributes);

    const osThreadAttr_t fanTask_attributes = {
      .name = "FanTask",
      .priority = (osPriority_t) osPriorityNormal,
      .stack_size = 256 * 4
    };
    fanTaskHandle = osThreadNew(StartFanTask, NULL, &fanTask_attributes);

    const osThreadAttr_t motorTask_attributes = {
      .name = "MotorTask",
      .priority = (osPriority_t) osPriorityAboveNormal,
      .stack_size = 256 * 4
    };
    motorTaskHandle = osThreadNew(StartMotorTask, NULL, &motorTask_attributes);

    /* Start scheduler */
    osKernelInitialize();
    osKernelStart();

    /* We should never get here as control is now taken by the scheduler */
    while (1)
    {
    }
}

/* ---------------- Task Implementations ---------------- */

void StartLEDTask(void *argument)
{
    (void) argument;
    for (;;)
    {
        HAL_GPIO_TogglePin(LED_GPIO_Port, LED_Pin);
        uart_printf("LED toggled\r\n");
        osDelay(500); // 500 ms
    }
}

void StartFanTask(void *argument)
{
    (void) argument;
    uint32_t adcValue = 0;
    for (;;)
    {
        /* Trigger ADC conversion and read value (blocking) */
        HAL_ADC_Start(&hadc1);
        if (HAL_ADC_PollForConversion(&hadc1, 10) == HAL_OK)
        {
            adcValue = HAL_ADC_GetValue(&hadc1);
        }
        HAL_ADC_Stop(&hadc1);

        if (adcValue > FAN_TEMP_THRESHOLD)
        {
            HAL_GPIO_WritePin(FAN_GPIO_Port, FAN_Pin, GPIO_PIN_SET); // Fan ON
            uart_printf("Fan ON (ADC=%lu)\r\n", (unsigned long)adcValue);
        }
        else
        {
            HAL_GPIO_WritePin(FAN_GPIO_Port, FAN_Pin, GPIO_PIN_RESET); // Fan OFF
            uart_printf("Fan OFF (ADC=%lu)\r\n", (unsigned long)adcValue);
        }

        osDelay(1000); // check every 1 s
    }
}

void StartMotorTask(void *argument)
{
    (void) argument;
    uint32_t duty = 0;
    int dir = 1;

    for (;;)
    {
        /* Ramp up */
        for (duty = 0; duty <= MOTOR_PWM_MAX; duty += MOTOR_STEP)
        {
            __HAL_TIM_SET_COMPARE(&htim3, TIM_CHANNEL_1, duty);
            osDelay(MOTOR_STEP_DELAY);
        }
        /* Ramp down */
        for (duty = MOTOR_PWM_MAX; (int)duty >= 0; duty -= MOTOR_STEP)
        {
            __HAL_TIM_SET_COMPARE(&htim3, TIM_CHANNEL_1, duty);
            osDelay(MOTOR_STEP_DELAY);
        }

        uart_printf("Motor cycle complete\r\n");

        osDelay(500); // small pause between cycles
    }
}

/* ---------------- System and MX stub functions ---------------- */
/* Implementations for SystemClock_Config, MX_GPIO_Init, MX_ADC1_Init,
   MX_TIM3_Init, MX_USART2_UART_Init are expected to be generated by
   STM32CubeIDE (CubeMX) according to your board and peripheral choices.
   If you prefer, you can write them manually or copy from CubeMX output. */

void SystemClock_Config(void)
{
    /* Generated by CubeMX - placeholder */
}

void MX_GPIO_Init(void)
{
    /* Generated by CubeMX - placeholder */
}

void MX_ADC1_Init(void)
{
    /* Generated by CubeMX - placeholder */
}

void MX_TIM3_Init(void)
{
    /* Generated by CubeMX - placeholder */
}

void MX_USART2_UART_Init(void)
{
    /* Generated by CubeMX - placeholder */
}
